# Supabase Patternsnn## OverviewnnThis document outlines the patterns and conventions for using Supabase in React TypeScript projects. These patterns ensure consistent, secure, and efficient database operations.nn## Client Setup Patternnn### Supabase Client Configurationn```typescriptnimport { createClient } from '@supabase/supabase-js'nimport { Database } from './types'nnconst supabaseUrl = import.meta.env.VITE_SUPABASE_URLnconst supabaseAnonKey = import.meta.env.VITE_SUPABASE_ANON_KEYnnif (!supabaseUrl || !supabaseAnonKey) {n  throw new Error('Missing Supabase environment variables')n}nnexport const supabase = createClient<Database>(supabaseUrl, supabaseAnonKey, {n  auth: {n    autoRefreshToken: true,n    persistSession: true,n    detectSessionInUrl: truen  },n  realtime: {n    params: {n      eventsPerSecond: 10n    }n  }n})```nn### Type Generationn```typescriptn// types.ts - Generated from Supabase CLI:n// supabase gen types typescript --project-id your-project-id > types.tsnnexport interface Database {n  public: {n    Tables: {n      users: {n        Row: {n          id: stringn          email: stringn          created_at: stringn          updated_at: stringn        }n        Insert: {n          id?: stringn          email: stringn          created_at?: stringn          updated_at?: stringn        }n        Update: {n          id?: stringn          email?: stringn          created_at?: stringn          updated_at?: stringn        }n      }n      // ... other tablesn    }n  }n}```nn## Authentication Patternsnn### Auth Context Patternn```typescriptnimport { createContext, useContext, useEffect, useState, ReactNode } from 'react'nimport { User, Session } from '@supabase/supabase-js'nimport { supabase } from './supabase-client'nninterface AuthContextType {n  user: User | nulln  session: Session | nulln  loading: booleann  signIn: (email: string, password: string) => Promise<void>n  signUp: (email: string, password: string) => Promise<void>n  signOut: () => Promise<void>n}nnconst AuthContext = createContext<AuthContextType | null>(null)nnexport const AuthProvider: React.FC<{ children: ReactNode }> = ({ children }) => {n  const [user, setUser] = useState<User | null>(null)n  const [session, setSession] = useState<Session | null>(null)n  const [loading, setLoading] = useState(true)n  n  useEffect(() => {n    // Get initial sessionn    supabase.auth.getSession().then(({ data: { session } }) => {n      setSession(session)n      setUser(session?.user ?? null)n      setLoading(false)n    })n    n    // Listen for auth changesn    const { data: { subscription } } = supabase.auth.onAuthStateChange(n      async (event, session) => {n        setSession(session)n        setUser(session?.user ?? null)n        setLoading(false)n      }n    )n    n    return () => subscription.unsubscribe()n  }, [])n  n  const signIn = async (email: string, password: string) => {n    const { error } = await supabase.auth.signInWithPassword({ email, password })n    if (error) throw errorn  }n  n  const signUp = async (email: string, password: string) => {n    const { error } = await supabase.auth.signUp({ email, password })n    if (error) throw errorn  }n  n  const signOut = async () => {n    const { error } = await supabase.auth.signOut()n    if (error) throw errorn  }n  n  return (n    <AuthContext.Provider value={{n      user,n      session,n      loading,n      signIn,n      signUp,n      signOutn    }}>n      {children}n    </AuthContext.Provider>n  )n}nnexport const useAuth = () => {n  const context = useContext(AuthContext)n  if (!context) {n    throw new Error('useAuth must be used within AuthProvider')n  }n  return contextn}```nn## Database Query Patternsnn### Basic CRUD Operationsn```typescriptnimport { supabase } from './supabase-client'nimport type { Database } from './types'nntype User = Database['public']['Tables']['users']['Row']ntype InsertUser = Database['public']['Tables']['users']['Insert']ntype UpdateUser = Database['public']['Tables']['users']['Update']nn// Create (Insert)nconst createUser = async (userData: InsertUser): Promise<User> => {n  const { data, error } = await supabasen    .from('users')n    .insert(userData)n    .select()n    .single()n  n  if (error) throw errorn  return datan}nn// Read (Select)nconst getUser = async (id: string): Promise<User | null> => {n  const { data, error } = await supabasen    .from('users')n    .select('*')n    .eq('id', id)n    .single()n  n  if (error) throw errorn  return datan}nnconst getUsers = async (): Promise<User[]> => {n  const { data, error } = await supabasen    .from('users')n    .select('*')n    .order('created_at', { ascending: false })n  n  if (error) throw errorn  return data || []n}nn// Updatenconst updateUser = async (id: string, updates: UpdateUser): Promise<User> => {n  const { data, error } = await supabasen    .from('users')n    .update(updates)n    .eq('id', id)n    .select()n    .single()n  n  if (error) throw errorn  return datan}nn// Deletenconst deleteUser = async (id: string): Promise<void> => {n  const { error } = await supabasen    .from('users')n    .delete()n    .eq('id', id)n  n  if (error) throw errorn}```nn### Advanced Query Patternsn```typescriptn// Paginationnconst getUsersPaginated = async (page: number, limit: number = 10) => {n  const from = page * limitn  const to = from + limit - 1n  n  const { data, error, count } = await supabasen    .from('users')n    .select('*', { count: 'exact' })n    .range(from, to)n    .order('created_at', { ascending: false })n  n  if (error) throw errorn  return { data: data || [], count: count || 0 }n}nn// Filtering and Searchingnconst searchUsers = async (searchTerm: string) => {n  const { data, error } = await supabasen    .from('users')n    .select('*')n    .or(`email.ilike.%${searchTerm}%,name.ilike.%${searchTerm}%`)n    .order('created_at', { ascending: false })n  n  if (error) throw errorn  return data || []n}nn// Joinsnconst getUsersWithProfiles = async () => {n  const { data, error } = await supabasen    .from('users')n    .select(`n      *,n      profiles (*)n    `)n    .order('created_at', { ascending: false })n  n  if (error) throw errorn  return data || []n}```nn## Real-time Patternsnn### Real-time Subscriptionsn```typescriptnimport { useEffect, useState } from 'react'nimport { supabase } from './supabase-client'nimport type { Database } from './types'nntype User = Database['public']['Tables']['users']['Row']nnconst useRealtimeUsers = () => {n  const [users, setUsers] = useState<User[]>([])n  const [loading, setLoading] = useState(true)nn  useEffect(() => {n    // Get initial datan    const fetchUsers = async () => {n      const { data } = await supabasen        .from('users')n        .select('*')n        .order('created_at', { ascending: false })n      setUsers(data || [])n      setLoading(false)n    }n    n    fetchUsers()n    n    // Set up real-time subscriptionn    const subscription = supabasen      .channel('users_changes')n      .on('postgres_changes',n        { event: '*', schema: 'public', table: 'users' },n        (payload) => {n          if (payload.eventType === 'INSERT') {n            setUsers(prev => [payload.new as User, ...prev])n          } else if (payload.eventType === 'UPDATE') {n            setUsers(prev => prev.map(user =>n              user.id === payload.new.id ? payload.new as User : usern            ))n          } else if (payload.eventType === 'DELETE') {n            setUsers(prev => prev.filter(user => user.id !== payload.old.id))n          }n        }n      )n      .subscribe()n    n    return () => {n      subscription.unsubscribe()n    }n  }, [])n  n  return { users, loading }n}```nn## Storage Patternsnn### File Upload Patternn```typescriptnimport { supabase } from './supabase-client'nnconst uploadFile = async (file: File, bucket: string = 'avatars') => {n  const fileExt = file.name.split('.').pop()n  const fileName = `${Math.random()}.${fileExt}`n  const filePath = `${fileName}`n  n  const { error: uploadError } = await supabase.storagen    .from(bucket)n    .upload(filePath, file)n  n  if (uploadError) throw uploadErrorn  n  const { data: { publicUrl } } = supabase.storagen    .from(bucket)n    .getPublicUrl(filePath)n  n  return publicUrln}nnconst deleteFile = async (filePath: string, bucket: string = 'avatars') => {n  const { error } = await supabase.storagen    .from(bucket)n    .remove([filePath])n  n  if (error) throw errorn}```nn## Error Handling Patternsnn### Custom Error Handlern```typescriptnimport { PostgrestError } from '@supabase/supabase-js'nnclass SupabaseError extends Error {n  constructor(n    message: string,n    public code: string,n    public details: string,n    public hint: stringn  ) {n    super(message)n    this.name = 'SupabaseError'n  }n}nnconst handleSupabaseError = (error: PostgrestError): never => {n  throw new SupabaseError(n    error.message,n    error.code,n    error.details,n    error.hintn  )n}nn// Usage in queriesnconst safeQuery = async () => {n  try {n    const { data, error } = await supabase.from('users').select('*')n    if (error) handleSupabaseError(error)n    return datan  } catch (error) {n    if (error instanceof SupabaseError) {n      console.error('Database error:', error.message)n      // Handle specific error typesn    } else {n      console.error('Unexpected error:', error)n    }n    throw errorn  }n}```nn## Best Practicesnn### 1. Row Level Security (RLS)n- Always enable RLS on tablesn- Create policies for each operationn- Test policies thoroughlyn- Use auth.uid() for user-specific datann### 2. Type Safetyn- Generate types from your database scheman- Use strict typing for all operationsn- Avoid type assertions when possiblen- Keep types in sync with schema changesnn### 3. Performancen- Use select() to limit returned columnsn- Implement proper paginationn- Use indexes for frequently queried columnsn- Monitor query performancenn### 4. Securityn- Never expose service role key in clientn- Use RLS policies for data access controln- Validate input data before queriesn- Use prepared statements (automatic with Supabase)nn## Common Pitfallsnn### 1. Not Handling Auth State Changesn```typescriptn// ❌ Wrongnconst [user, setUser] = useState(null)n// Missing auth state listenernn// ✅ CorrectnuseEffect(() => {n  const { data: { subscription } } = supabase.auth.onAuthStateChange(n    (event, session) => {n      setUser(session?.user ?? null)n    }n  )n  return () => subscription.unsubscribe()n}, [])n```nn### 2. Not Using Proper Error Handlingn```typescriptn// ❌ Wrongnconst { data } = await supabase.from('users').select('*')nreturn data // Might be null or throw errornn// ✅ Correctnconst { data, error } = await supabase.from('users').select('*')nif (error) throw errornreturn data || []n```nn### 3. Not Cleaning Up Subscriptionsn```typescriptn// ❌ WrongnuseEffect(() => {n  const subscription = supabase.channel('test').subscribe()n  // Missing cleanupnn// ✅ CorrectnuseEffect(() => {n  const subscription = supabase.channel('test').subscribe()n  return () => subscription.unsubscribe()n}, [])n```nn## Related Patternsn- [React TypeScript Conventions](react-typescript-conventions.md) - Component patternsn- [Authentication Patterns](auth-patterns.md) - Auth flow patternsn- [Error Handling Patterns](error-handling-patterns.md) - Error managementnn## Examplesn- User authentication flown- Real-time data synchronizationn- File upload and managementn- Database CRUD operationsn- Row Level Security implementation