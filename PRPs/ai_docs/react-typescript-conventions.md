# React TypeScript Conventionsnn## OverviewnnThis document outlines the coding conventions and patterns used in React TypeScript projects. These patterns ensure consistent, maintainable, and type-safe code generation.nn## Component Patternsnn### Functional Components with Hooksn```typescriptnimport React from 'react'nimport { useState, useEffect } from 'react'nninterface ComponentProps {n  title: stringn  onAction?: (data: string) => voidn  disabled?: booleann}nnconst MyComponent: React.FC<ComponentProps> = ({n  title,n  onAction,n  disabled = falsen}) => {n  const [state, setState] = useState<string>('')n  n  useEffect(() => {n    // Side effect logicn  }, [])n  n  const handleClick = () => {n    if (onAction) {n      onAction(state)n    }n  }n  n  return (n    <div className="p-4 border rounded-lg">n      <h2 className="text-xl font-semibold">{title}</h2>n      <buttonn        onClick={handleClick}n        disabled={disabled}n        className="px-4 py-2 bg-blue-500 text-white rounded disabled:opacity-50"n      >n        Actionn      </button>n    </div>n  )n}nnexport default MyComponentn```nn### Custom Hooks Patternn```typescriptnimport { useState, useEffect } from 'react'nninterface UseCustomHookReturn {n  data: anyn  loading: booleann  error: string | nulln  refetch: () => voidn}nnconst useCustomHook = (url: string): UseCustomHookReturn => {n  const [data, setData] = useState<any>(null)n  const [loading, setLoading] = useState<boolean>(true)n  const [error, setError] = useState<string | null>(null)n  n  const fetchData = async () => {n    try {n      setLoading(true)n      setError(null)n      const response = await fetch(url)n      const result = await response.json()n      setData(result)n    } catch (err) {n      setError(err instanceof Error ? err.message : 'Unknown error')n    } finally {n      setLoading(false)n    }n  }n  n  useEffect(() => {n    fetchData()n  }, [url])n  n  return { data, loading, error, refetch: fetchData }n}nnexport default useCustomHookn```nn## State Management Patternsnn### Context with Provider Patternn```typescriptnimport React, { createContext, useContext, useReducer, ReactNode } from 'react'nninterface AppState {n  user: User | nulln  theme: 'light' | 'dark'n  notifications: Notification[]n}nninterface AppAction {n  type: stringn  payload?: anyn}nnconst initialState: AppState = {n  user: null,n  theme: 'light',n  notifications: []n}nnconst appReducer = (state: AppState, action: AppAction): AppState => {n  switch (action.type) {n    case 'SET_USER':n      return { ...state, user: action.payload }n    case 'SET_THEME':n      return { ...state, theme: action.payload }n    case 'ADD_NOTIFICATION':n      return { ...state, notifications: [...state.notifications, action.payload] }n    default:n      return staten  }n}nnconst AppContext = createContext<{n  state: AppStaten  dispatch: React.Dispatch<AppAction>n} | null>(null)nnexport const AppProvider: React.FC<{ children: ReactNode }> = ({ children }) => {n  const [state, dispatch] = useReducer(appReducer, initialState)n  n  return (n    <AppContext.Provider value={{ state, dispatch }}>n      {children}n    </AppContext.Provider>n  )n}nnexport const useApp = () => {n  const context = useContext(AppContext)n  if (!context) {n    throw new Error('useApp must be used within AppProvider')n  }n  return contextn}```nn## Error Handling Patternsnn### Error Boundary Patternn```typescriptnimport React, { Component, ReactNode } from 'react'nninterface ErrorBoundaryState {n  hasError: booleann  error?: Errorn}nninterface ErrorBoundaryProps {n  children: ReactNoden  fallback?: ReactNoden}nnclass ErrorBoundary extends Component<ErrorBoundaryProps, ErrorBoundaryState> {n  constructor(props: ErrorBoundaryProps) {n    super(props)n    this.state = { hasError: false }n  }n  n  static getDerivedStateFromError(error: Error): ErrorBoundaryState {n    return { hasError: true, error }n  }n  n  componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {n    console.error('Error caught by boundary:', error, errorInfo)n  }n  n  render() {n    if (this.state.hasError) {n      return this.props.fallback || (n        <div className="p-4 bg-red-50 border border-red-200 rounded">n          <h2 className="text-red-800 font-semibold">Something went wrong</h2>n          <p className="text-red-600">{this.state.error?.message}</p>n        </div>n      )n    }n    n    return this.props.childrenn  }n}nnexport default ErrorBoundaryn```nn## Form Handling Patternsnn### Controlled Form Patternn```typescriptnimport React, { useState, FormEvent } from 'react'nninterface FormData {n  email: stringn  password: stringn  rememberMe: booleann}nnconst LoginForm: React.FC = () => {n  const [formData, setFormData] = useState<FormData>({n    email: '',n    password: '',n    rememberMe: falsen  })n  const [errors, setErrors] = useState<Partial<FormData>>({})n  n  const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {n    const { name, value, type, checked } = e.targetn    setFormData(prev => ({n      ...prev,n      [name]: type === 'checkbox' ? checked : valuen    }))n    // Clear error when user starts typingn    if (errors[name as keyof FormData]) {n      setErrors(prev => ({ ...prev, [name]: undefined }))n    }n  }n  n  const handleSubmit = async (e: FormEvent) => {n    e.preventDefault()n    // Validation logicn    const newErrors: Partial<FormData> = {}n    if (!formData.email) newErrors.email = 'Email is required'n    if (!formData.password) newErrors.password = 'Password is required'n    n    if (Object.keys(newErrors).length > 0) {n      setErrors(newErrors)n      returnn    }n    n    // Submit logicn    try {n      // API call heren      console.log('Form submitted:', formData)n    } catch (error) {n      console.error('Submit error:', error)n    }n  }n  n  return (n    <form onSubmit={handleSubmit} className="space-y-4">n      <div>n        <label htmlFor="email" className="block text-sm font-medium">n          Emailn        </label>n        <inputn          type="email"n          id="email"n          name="email"n          value={formData.email}n          onChange={handleChange}n          className={`mt-1 block w-full rounded-md border ${n            errors.email ? 'border-red-500' : 'border-gray-300'n          }`}n        />n        {errors.email && (n          <p className="mt-1 text-sm text-red-600">{errors.email}</p>n        )}n      </div>n      {/* Similar pattern for password and checkbox */}n      <buttonn        type="submit"n        className="w-full px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600"n      >n        Loginn      </button>n    </form>n  )n}nnexport default LoginFormn```nn## Best Practicesnn### 1. Type Safetyn- Always define interfaces for props and staten- Use strict TypeScript configurationn- Avoid `any` type when possiblen- Use union types for better type safetynn### 2. Performance Optimizationn- Use React.memo for expensive componentsn- Implement proper dependency arrays in useEffectn- Use useCallback for function propsn- Use useMemo for expensive calculationsnn### 3. Code Organizationn- One component per filen- Use index files for clean importsn- Group related components in foldersn- Separate business logic from UI componentsnn### 4. Naming Conventionsn- Use PascalCase for componentsn- Use camelCase for functions and variablesn- Use UPPER_CASE for constantsn- Use descriptive names that explain purposenn## Common Pitfallsnn### 1. Missing Dependencies in useEffectn```typescriptn// ❌ WrongnuseEffect(() => {n  fetchData(id)n}, []) // Missing id dependencynn// ✅ CorrectnuseEffect(() => {n  fetchData(id)n}, [id])n```nn### 2. Not Handling Loading Statesn```typescriptn// ❌ Wrongnconst { data } = useCustomHook(url)nreturn <div>{data.name}</div> // Will crash if data is nullnn// ✅ Correctnconst { data, loading, error } = useCustomHook(url)nif (loading) return <div>Loading...</div>nif (error) return <div>Error: {error}</div>nif (!data) return <div>No data</div>nreturn <div>{data.name}</div>n```nn### 3. Not Using Proper Event Typesn```typescriptn// ❌ Wrongnconst handleClick = (e) => {n  console.log(e.target.value)n}nn// ✅ Correctnconst handleClick = (e: React.MouseEvent<HTMLButtonElement>) => {n  console.log(e.currentTarget.value)n}```nn## Related Patternsn- [Supabase Patterns](supabase-patterns.md) - Database integration patternsn- [Tailwind Patterns](tailwind-patterns.md) - Styling patternsn- [Testing Patterns](jest-testing-patterns.md) - Testing conventionsnn## Examplesn- Form validation with error handlingn- API integration with loading statesn- State management with Contextn- Custom hooks for reusable logicn- Error boundaries for graceful failures