# New Project

## Description
Creates a new project from scratch with comprehensive setup including `claude.md`, `initial.md`, PRP system, and **project-specific AI agents** generated by the meta-agent. This provides tailored AI assistance optimized for your specific project needs and technology stack.

## Usage
```
/new-project [project-description]
```

## Arguments
- `project-description` (optional): Description of what you want the project to do

## Behavior
1. **Project Validation**: Ensures we're starting fresh (no existing project files)
2. **User Input Collection**: Prompts for project description if not provided
3. **Technology Stack Detection**: Analyzes project description to infer tech stack
4. **CLAUDE.md Creation**: Creates a comprehensive `claude.md` file for the new project
5. **INITIAL.md Creation**: Creates an `initial.md` file with project initialization details
6. **PRP System Setup**: Sets up the PRP system for the new project
7. **Project-Specific Agent Creation**: Uses meta-agent to generate custom agents for this project
8. **Project Structure**: Creates basic project structure and documentation
9. **Agent Documentation**: Creates documentation for the generated project agents

## Example Usage
```
# Creates project with auto-generated agents for React, Node.js, and database management
/new-project "A web application for task management with user authentication"

# Creates project with agents for Python/Django and PostgreSQL
/new-project "A Django-based e-commerce platform with inventory management"

# Creates project with agents for machine learning and data processing
/new-project "A Python ML pipeline for analyzing customer behavior data"
```

## Implementation
```python
import os
import sys
from pathlib import Path
from datetime import datetime

def create_new_project(project_description=None):
    """
    Create a new project from scratch with PRP system setup and project-specific agents.
    """
    current_dir = Path.cwd()
    
    # Check if directory is empty or has minimal content
    existing_files = [f for f in current_dir.iterdir() if f.name not in ['.git', '.gitignore']]
    if existing_files:
        print("‚ö†Ô∏è  Directory contains files. Consider using /analyze-project for existing projects.")
        response = input("Continue with new project setup? (y/N): ")
        if response.lower() != 'y':
            print("‚ùå New project setup cancelled.")
            return
    
    # Get project description if not provided
    if not project_description:
        print("üéØ Let's create a new project!")
        print("Please describe what you want your project to do:")
        project_description = input("Project description: ").strip()
        
        if not project_description:
            print("‚ùå Project description is required.")
            return
    
    print(f"üöÄ Creating new project: {project_description}")
    
    # Analyze project to determine technology stack and requirements
    tech_stack = analyze_project_tech_stack(project_description)
    print(f"üîç Detected technology stack: {', '.join(tech_stack)}")
    
    # Create claude.md
    create_claude_md_for_new_project(current_dir, project_description, tech_stack)
    
    # Create initial.md
    create_initial_md_for_new_project(current_dir, project_description, tech_stack)
    
    # Set up PRP system
    setup_prp_system_for_new_project(current_dir, project_description)
    
    # Create project-specific agents using meta-agent
    created_agents = create_project_specific_agents(current_dir, project_description, tech_stack)
    
    # Create basic project structure
    create_basic_project_structure(current_dir, project_description, tech_stack)
    
    # Create agent documentation
    create_agent_documentation(current_dir, created_agents, tech_stack)
    
    print("‚úÖ New project created successfully!")
    print("ü§ñ Generated project-specific agents:")
    for agent in created_agents:
        print(f"   ‚Ä¢ {agent}")
    print("üìÅ Next steps:")
    print("   1. Review claude.md for project guidelines and available agents")
    print("   2. Check initial.md for project initialization")
    print("   3. Use your custom agents for specialized tasks")
    print("   4. Use /prp-create to create your first feature requirement")
    print("   5. Start building your project!")

def analyze_project_tech_stack(description):
    """Analyze project description to determine likely technology stack."""
    tech_stack = []
    description_lower = description.lower()
    
    # Frontend technologies
    if any(term in description_lower for term in ['web app', 'frontend', 'react', 'vue', 'angular', 'ui', 'interface']):
        if 'react' in description_lower:
            tech_stack.append('React')
        elif 'vue' in description_lower:
            tech_stack.append('Vue.js')
        elif 'angular' in description_lower:
            tech_stack.append('Angular')
        else:
            tech_stack.append('React')  # Default frontend
    
    # Backend technologies
    if any(term in description_lower for term in ['api', 'backend', 'server', 'authentication', 'database']):
        if 'python' in description_lower or 'django' in description_lower:
            tech_stack.append('Python/Django')
        elif 'node' in description_lower or 'express' in description_lower:
            tech_stack.append('Node.js/Express')
        elif 'java' in description_lower or 'spring' in description_lower:
            tech_stack.append('Java/Spring')
        elif 'go' in description_lower or 'golang' in description_lower:
            tech_stack.append('Go')
        else:
            tech_stack.append('Node.js/Express')  # Default backend
    
    # Database technologies
    if any(term in description_lower for term in ['database', 'data', 'storage', 'postgres', 'mysql', 'mongo']):
        if 'postgres' in description_lower:
            tech_stack.append('PostgreSQL')
        elif 'mysql' in description_lower:
            tech_stack.append('MySQL')
        elif 'mongo' in description_lower:
            tech_stack.append('MongoDB')
        else:
            tech_stack.append('PostgreSQL')  # Default database
    
    # Machine Learning
    if any(term in description_lower for term in ['ml', 'machine learning', 'ai', 'data science', 'model', 'prediction']):
        tech_stack.append('Python/ML')
    
    # Mobile
    if any(term in description_lower for term in ['mobile', 'ios', 'android', 'react native', 'flutter']):
        if 'react native' in description_lower:
            tech_stack.append('React Native')
        elif 'flutter' in description_lower:
            tech_stack.append('Flutter')
        else:
            tech_stack.append('React Native')  # Default mobile
    
    # DevOps/Infrastructure
    if any(term in description_lower for term in ['deploy', 'cloud', 'aws', 'docker', 'kubernetes']):
        tech_stack.append('DevOps/Cloud')
    
    return tech_stack if tech_stack else ['Full-Stack']

def create_project_specific_agents(project_dir, description, tech_stack):
    """Create project-specific agents using meta-agent."""
    agents_dir = project_dir / ".claude" / "agents"
    agents_dir.mkdir(parents=True, exist_ok=True)
    
    created_agents = []
    
    # Agent creation prompts based on tech stack
    agent_configs = generate_agent_configs(description, tech_stack)
    
    for agent_config in agent_configs:
        print(f"ü§ñ Creating {agent_config['name']} agent...")
        
        # This would use the meta-agent to create the actual agent file
        agent_content = create_agent_with_meta_agent(agent_config)
        
        # Write agent file
        agent_path = agents_dir / f"{agent_config['name']}.md"
        with open(agent_path, 'w') as f:
            f.write(agent_content)
        
        created_agents.append(agent_config['name'])
        print(f"‚úÖ Created {agent_config['name']} agent")
    
    return created_agents

def generate_agent_configs(description, tech_stack):
    """Generate agent configurations based on project needs."""
    configs = []
    
    # Always create a project-coordinator agent
    configs.append({
        'name': 'project-coordinator',
        'description': f'Project coordinator for managing {description} development workflow and task prioritization',
        'role': 'Project Management',
        'domain': 'Project Coordination'
    })
    
    # Frontend agents
    if any('React' in stack or 'Vue' in stack or 'Angular' in stack for stack in tech_stack):
        frontend_tech = next((stack for stack in tech_stack if any(f in stack for f in ['React', 'Vue', 'Angular'])), 'React')
        configs.append({
            'name': 'frontend-specialist',
            'description': f'{frontend_tech} specialist for building user interfaces and client-side functionality',
            'role': 'Frontend Development',
            'domain': f'{frontend_tech} Development'
        })
    
    # Backend agents
    if any('Django' in stack or 'Express' in stack or 'Spring' in stack or 'Go' in stack for stack in tech_stack):
        backend_tech = next((stack for stack in tech_stack if any(b in stack for b in ['Django', 'Express', 'Spring', 'Go'])), 'Node.js/Express')
        configs.append({
            'name': 'backend-specialist',
            'description': f'{backend_tech} specialist for API development, authentication, and server-side logic',
            'role': 'Backend Development',
            'domain': f'{backend_tech} Development'
        })
    
    # Database agents
    if any('PostgreSQL' in stack or 'MySQL' in stack or 'MongoDB' in stack for stack in tech_stack):
        db_tech = next((stack for stack in tech_stack if any(d in stack for d in ['PostgreSQL', 'MySQL', 'MongoDB'])), 'PostgreSQL')
        configs.append({
            'name': 'database-specialist',
            'description': f'{db_tech} database specialist for schema design, queries, and data management',
            'role': 'Database Management',
            'domain': f'{db_tech} Database'
        })
    
    # ML agents
    if any('ML' in stack for stack in tech_stack):
        configs.append({
            'name': 'ml-specialist',
            'description': 'Machine learning specialist for model development, data processing, and ML pipeline management',
            'role': 'Machine Learning',
            'domain': 'ML/Data Science'
        })
    
    # DevOps agents
    if any('DevOps' in stack or 'Cloud' in stack for stack in tech_stack):
        configs.append({
            'name': 'devops-specialist',
            'description': 'DevOps specialist for deployment, infrastructure, CI/CD, and cloud management',
            'role': 'DevOps/Infrastructure',
            'domain': 'Cloud/DevOps'
        })
    
    # Testing agent (always created)
    configs.append({
        'name': 'testing-specialist',
        'description': f'Testing specialist for unit tests, integration tests, and quality assurance across {", ".join(tech_stack)}',
        'role': 'Quality Assurance',
        'domain': 'Testing/QA'
    })
    
    return configs

def create_agent_with_meta_agent(agent_config):
    """Create agent content using meta-agent patterns."""
    # This simulates what the meta-agent would create
    agent_content = f"""---
name: {agent_config['name']}
description: {agent_config['description']}. Use proactively for {agent_config['domain'].lower()} tasks and specialized guidance.
tools: Task, Read, Write, Edit, MultiEdit, Bash, WebSearch
color: Blue
---

# Purpose

You are a {agent_config['role'].lower()} specialist focused on {agent_config['domain'].lower()}. Your expertise covers all aspects of {agent_config['domain'].lower()} within this project context.

## Instructions

When invoked, you must follow these steps:

1. **Analyze Requirements**
   - Review the project context and specific {agent_config['domain'].lower()} requirements
   - Identify key technical constraints and business requirements
   - Understand the integration points with other project components

2. **Provide Specialized Guidance**
   - Offer expert advice on {agent_config['domain'].lower()} best practices
   - Recommend appropriate tools, libraries, and patterns
   - Identify potential challenges and provide solutions
   - Suggest optimization opportunities

3. **Implementation Support**
   - Provide detailed implementation plans and code examples
   - Review existing code for {agent_config['domain'].lower()} concerns
   - Suggest testing strategies appropriate for {agent_config['domain'].lower()}
   - Ensure adherence to {agent_config['domain'].lower()} standards and conventions

4. **Quality Assurance**
   - Validate {agent_config['domain'].lower()} implementations against requirements
   - Identify security, performance, and maintainability concerns
   - Provide refactoring suggestions when needed
   - Ensure documentation is complete and accurate

**Best Practices:**
- Focus specifically on {agent_config['domain'].lower()} aspects of the project
- Coordinate with other project specialists when needed
- Stay current with {agent_config['domain'].lower()} industry standards and trends
- Provide actionable, specific guidance rather than generic advice
- Consider the project's specific context and constraints in all recommendations

## Report / Response

Provide your analysis and recommendations in a clear, organized manner with:
- Executive summary of key findings
- Detailed recommendations with rationale
- Implementation steps and code examples where applicable
- Risk assessment and mitigation strategies
- Next steps and follow-up actions needed
"""
    
    return agent_content

def create_claude_md_for_new_project(project_dir, description, tech_stack):
    """Create a comprehensive claude.md file for a new project."""
    agents_list = generate_agent_configs(description, tech_stack)
    agent_names = [agent['name'] for agent in agents_list]
    
    content = f"""# Project Development Guide

## Project Overview
**Project Goal:** {description}
**Technology Stack:** {', '.join(tech_stack)}

## Project Context
- **Project Type:** New Development
- **Start Date:** {datetime.now().strftime('%Y-%m-%d')}
- **Development Approach:** PRP (Product Requirement Prompt) System with Project-Specific AI Agents

## Development Philosophy
This project follows a structured development approach using the PRP system enhanced with project-specific AI agents:

### Core Principles
1. **Requirement-Driven Development**: Every feature starts with a clear PRP
2. **Agent-Assisted Development**: Leverage specialized AI agents for domain expertise
3. **Incremental Building**: Build features one at a time with clear success criteria
4. **Documentation-First**: Maintain clear documentation throughout development
5. **Quality Assurance**: Test each feature before moving to the next

### PRP System with Agent Integration Workflow
1. **Create PRP**: Use `/prp-create` to define a new feature requirement with agent research
2. **Agent Consultation**: Use project-specific agents for specialized guidance
3. **Plan Implementation**: Use `/plan` with agent input to create development plans
4. **Build Feature**: Implement the feature with agent assistance and code review
5. **Validate**: Ensure the feature meets all success criteria using testing agents
6. **Document**: Update documentation and create next PRP

## Project-Specific AI Agents

This project includes custom AI agents tailored to your technology stack:

{chr(10).join([f"- **{agent['name']}**: {agent['description']}" for agent in agents_list])}

### How to Use Your Custom Agents
- Agents are automatically triggered based on task context
- Use `/task` to explicitly invoke a specific agent
- Agents work together and can coordinate on complex tasks
- Each agent has specialized knowledge for their domain

## Project Structure
```
{project_dir.name}/
‚îú‚îÄ‚îÄ .claude/           # Claude Code configuration
‚îÇ   ‚îî‚îÄ‚îÄ agents/        # Project-specific AI agents
‚îú‚îÄ‚îÄ claude.md          # This file - project guidelines  
‚îú‚îÄ‚îÄ initial.md         # Project initialization details
‚îú‚îÄ‚îÄ README.md          # Project overview and setup
‚îú‚îÄ‚îÄ PRPs/              # Product Requirement Prompts
‚îÇ   ‚îú‚îÄ‚îÄ templates/     # PRP templates
‚îÇ   ‚îú‚îÄ‚îÄ examples/      # Example PRPs
‚îÇ   ‚îî‚îÄ‚îÄ ai_docs/       # AI documentation
‚îú‚îÄ‚îÄ src/               # Source code
‚îú‚îÄ‚îÄ docs/              # Documentation
‚îú‚îÄ‚îÄ tests/             # Test files
‚îî‚îÄ‚îÄ scripts/           # Utility scripts
```

## Technology Stack
{', '.join(tech_stack)}

## Development Guidelines
1. **Code Quality**: Write clean, maintainable code with agent assistance
2. **Agent Integration**: Leverage project-specific agents for specialized tasks
3. **Testing**: Include comprehensive tests with testing-specialist agent guidance
4. **Documentation**: Keep documentation up to date with agent-generated content
5. **Version Control**: Use meaningful commit messages with agent recommendations
6. **Incremental Development**: Build and test features incrementally with agent validation

## Available Commands
- `/prp-create` - Create a new Product Requirement Prompt with agent research
- `/prp-execute` - Execute PRPs with agent assistance
- `/review` - Comprehensive code and project review with agents
- `/task` - Invoke specific project agents
- Agent-specific commands available based on your technology stack

## Project Agents Available
{chr(10).join([f"- `{agent['name']}` - {agent['role']}" for agent in agents_list])}

## Success Metrics
- [ ] Project requirements clearly defined
- [ ] Core features implemented
- [ ] Documentation complete
- [ ] Tests passing
- [ ] Ready for deployment

## Next Steps
1. Review and refine project requirements
2. Create first PRP for core functionality
3. Set up development environment
4. Begin implementation
"""
    
    with open(project_dir / "claude.md", 'w') as f:
        f.write(content)
    print("‚úÖ Created comprehensive claude.md")

def create_agent_documentation(project_dir, created_agents, tech_stack):
    """Create documentation for the project-specific agents."""
    docs_dir = project_dir / "docs"
    docs_dir.mkdir(exist_ok=True)
    
    agent_docs_content = f"""# Project AI Agents Guide

## Overview
This project includes {len(created_agents)} custom AI agents specifically designed for your technology stack: {', '.join(tech_stack)}.

## Available Agents

{chr(10).join([f"### {agent.replace('-', ' ').title()}{chr(10)}**Agent Name**: `{agent}`{chr(10)}**Usage**: Use when working on {agent.replace('-', ' ')} related tasks{chr(10)}**Invocation**: Automatically triggered by context or via `/task {agent}`{chr(10)}" for agent in created_agents])}

## Agent Coordination

### Automatic Agent Selection
Claude Code automatically selects the most appropriate agent based on:
- File types being worked on
- Task context and requirements
- Technology stack components involved
- Development phase (planning, implementation, testing, deployment)

### Manual Agent Invocation
You can explicitly invoke agents using:
```
/task agent-name "Specific task description"
```

### Multi-Agent Workflows
For complex tasks, multiple agents work together:
1. **project-coordinator** orchestrates overall workflow
2. **frontend-specialist** and **backend-specialist** coordinate on full-stack features
3. **database-specialist** provides data architecture guidance
4. **testing-specialist** ensures quality across all components

## Best Practices

### When to Use Each Agent
- **project-coordinator**: Feature planning, milestone tracking, dependency management
- **frontend-specialist**: UI/UX implementation, state management, client-side optimization
- **backend-specialist**: API design, business logic, server architecture
- **database-specialist**: Schema design, query optimization, data migration
- **testing-specialist**: Test strategy, coverage analysis, quality assurance
- **devops-specialist**: Deployment, infrastructure, CI/CD pipeline
- **ml-specialist**: Model development, data processing, ML pipeline

### Agent Communication Patterns
1. **Sequential**: One agent completes work, passes to next
2. **Parallel**: Multiple agents work simultaneously on different aspects
3. **Collaborative**: Agents provide input and review each other's work
4. **Supervisory**: Coordinator agent manages and delegates to specialists

## Integration with PRP System

### Agent-Enhanced PRPs
When creating PRPs with `/prp-create`, relevant agents automatically:
- Provide technical research and best practices
- Suggest implementation approaches
- Identify potential challenges and solutions
- Generate validation criteria specific to their domain

### Agent-Assisted Implementation
During PRP execution with `/prp-execute`:
- Agents implement their specialized portions
- Cross-agent validation ensures integration
- Quality agents review and suggest improvements
- Testing agents create comprehensive test suites

## Troubleshooting

### Agent Not Responding
1. Check agent name spelling
2. Verify task context matches agent domain
3. Try explicit invocation with `/task agent-name`

### Multiple Agents Conflicting
1. Use project-coordinator to resolve conflicts
2. Clarify requirements and priorities
3. Sequential execution may be needed instead of parallel

### Agent Suggestions Not Relevant
1. Provide more specific context in your request
2. Include technology stack details
3. Specify project constraints and requirements

---
*Generated by new-project command with meta-agent integration*
"""
    
    agent_docs_path = docs_dir / "agents-guide.md"
    with open(agent_docs_path, 'w') as f:
        f.write(agent_docs_content)
    
    print("‚úÖ Created agent documentation")

def create_initial_md_for_new_project(project_dir, description, tech_stack):
    """Create initial.md for new project setup."""
    content = f"""# Project Initialization

## Project Description
**Goal:** {description}

## Initial Requirements Gathering
Before starting development, we need to gather more specific requirements:

### Functional Requirements
1. **Core Features:**
   - [ ] [Define core feature 1]
   - [ ] [Define core feature 2]
   - [ ] [Define core feature 3]

2. **User Stories:**
   - As a [user type], I want [feature] so that [benefit]
   - As a [user type], I want [feature] so that [benefit]

### Technical Requirements
1. **Technology Stack:**
   {chr(10).join([f'   - {tech}' for tech in tech_stack])}

2. **Performance Requirements:**
   - [ ] [Performance requirement 1]
   - [ ] [Performance requirement 2]

3. **Security Requirements:**
   - [ ] [Security requirement 1]
   - [ ] [Security requirement 2]

### Non-Functional Requirements
1. **Usability:**
   - [ ] [Usability requirement 1]
   - [ ] [Usability requirement 2]

2. **Scalability:**
   - [ ] [Scalability requirement 1]
   - [ ] [Scalability requirement 2]

## Project Scope
- **MVP Features:** [List minimum viable product features]
- **Future Enhancements:** [List future features]
- **Out of Scope:** [List what's not included]

## Timeline
- **Phase 1:** [Define phase 1 goals and timeline]
- **Phase 2:** [Define phase 2 goals and timeline]
- **Phase 3:** [Define phase 3 goals and timeline]

## Resources Needed
- **Development Tools:** [List required tools]
- **External Services:** [List external services]
- **Team Skills:** [List required skills]

## Risk Assessment
- **Technical Risks:** [List potential technical challenges]
- **Timeline Risks:** [List potential timeline issues]
- **Resource Risks:** [List potential resource constraints]

## Success Criteria
- [ ] [Success criterion 1]
- [ ] [Success criterion 2]
- [ ] [Success criterion 3]

## Next Actions
1. **Refine Requirements:** Complete the requirements gathering above
2. **Create First PRP:** Use `/prp` to create the first feature requirement
3. **Set Up Environment:** Configure development environment
4. **Begin Development:** Start with MVP features
"""
    
    with open(project_dir / "initial.md", 'w') as f:
        f.write(content)
    print("‚úÖ Created detailed initial.md")

def setup_prp_system_for_new_project(project_dir, description):
    """Set up PRP system for new project."""
    # Create PRPs directory structure
    prps_dir = project_dir / "PRPs"
    prps_dir.mkdir(exist_ok=True)
    
    # Create subdirectories
    (prps_dir / "templates").mkdir(exist_ok=True)
    (prps_dir / "examples").mkdir(exist_ok=True)
    (prps_dir / "ai_docs").mkdir(exist_ok=True)
    
    # Create new project PRP template
    template_content = """# New Project PRP Template

## Feature Request
**Description:** [Describe the feature to be built]

## User Story
As a [user type], I want [feature] so that [benefit]

## Requirements
### Functional Requirements
- [ ] [Requirement 1]
- [ ] [Requirement 2]
- [ ] [Requirement 3]

### Technical Requirements
- [ ] [Technical requirement 1]
- [ ] [Technical requirement 2]

### UI/UX Requirements
- [ ] [UI requirement 1]
- [ ] [UX requirement 2]

## Acceptance Criteria
- [ ] [Criterion 1]
- [ ] [Criterion 2]
- [ ] [Criterion 3]

## Technical Design
### Architecture
[Describe the technical architecture for this feature]

### Data Models
[Describe any new data models or changes to existing ones]

### API Endpoints
[Describe any new API endpoints needed]

### Database Changes
[Describe any database schema changes]

## Implementation Plan
1. **Step 1:** [Implementation step 1]
2. **Step 2:** [Implementation step 2]
3. **Step 3:** [Implementation step 3]

## Testing Strategy
- **Unit Tests:** [What to unit test]
- **Integration Tests:** [What to integration test]
- **User Acceptance Tests:** [What to UAT]

## Dependencies
- [ ] [Dependency 1]
- [ ] [Dependency 2]

## Success Metrics
- [ ] [Metric 1]
- [ ] [Metric 2]

## Notes
[Any additional notes or considerations]
"""
    
    template_path = prps_dir / "templates" / "new_project_template.md"
    with open(template_path, 'w') as f:
        f.write(template_content)
    
    # Create example PRP
    example_content = f"""# Example PRP: Project Setup

## Feature Request
**Description:** Set up the basic project structure and development environment

## User Story
As a developer, I want a well-organized project structure so that I can efficiently build the {description}

## Requirements
### Functional Requirements
- [ ] Create basic project directory structure
- [ ] Set up version control
- [ ] Configure development environment
- [ ] Create initial documentation

### Technical Requirements
- [ ] Choose appropriate technology stack
- [ ] Set up build/deployment pipeline
- [ ] Configure linting and formatting
- [ ] Set up testing framework

### UI/UX Requirements
- [ ] Design basic UI wireframes
- [ ] Define color scheme and typography
- [ ] Plan user flow

## Acceptance Criteria
- [ ] Project structure is organized and scalable
- [ ] Development environment is ready for coding
- [ ] Basic documentation is in place
- [ ] Technology stack is chosen and configured

## Technical Design
### Architecture
Basic project architecture with clear separation of concerns

### Data Models
Initial data models based on core features

### API Endpoints
Basic API structure for core functionality

### Database Changes
Initial database schema design

## Implementation Plan
1. **Step 1:** Research and choose technology stack
2. **Step 2:** Set up project structure
3. **Step 3:** Configure development tools
4. **Step 4:** Create initial documentation

## Testing Strategy
- **Unit Tests:** Basic test setup
- **Integration Tests:** Core functionality tests
- **User Acceptance Tests:** Basic user flow tests

## Dependencies
- [ ] Technology stack selection
- [ ] Development tools installation
- [ ] Documentation templates

## Success Metrics
- [ ] Project builds successfully
- [ ] Tests pass
- [ ] Documentation is clear and complete

## Notes
This is the foundational PRP for the project. All subsequent features will build upon this setup.
"""
    
    example_path = prps_dir / "examples" / "project_setup_example.md"
    with open(example_path, 'w') as f:
        f.write(example_content)
    
    print("‚úÖ Set up PRP system for new project")

def create_basic_project_structure(project_dir, description, tech_stack):
    """Create basic project structure."""
    # Create main directories
    (project_dir / "src").mkdir(exist_ok=True)
    (project_dir / "docs").mkdir(exist_ok=True)
    (project_dir / "tests").mkdir(exist_ok=True)
    (project_dir / "scripts").mkdir(exist_ok=True)
    
    # Create README.md
    readme_content = f"""# {project_dir.name}

## Project Description
{description}

## Technology Stack
{', '.join(tech_stack)}

## Getting Started
This project uses the PRP (Product Requirement Prompt) system enhanced with project-specific AI agents for structured development.

### Prerequisites
- Development environment for {', '.join(tech_stack)}
- Claude Code CLI for AI-assisted development

### Installation
1. Clone the repository
2. Install dependencies
3. Set up environment variables
4. Run the application

### Development with AI Agents
- Use `/prp-create` to create new feature requirements with agent research
- Use `/prp-execute` to implement features with agent assistance
- Use `/review` for comprehensive code and project review
- Use `/task agent-name` to invoke specific project agents
- Leverage automatic agent selection for context-aware assistance

## Project Structure
- `.claude/agents/` - Project-specific AI agents
- `claude.md` - Project development guidelines with agent information
- `initial.md` - Project initialization details
- `PRPs/` - Product Requirement Prompts
- `src/` - Source code
- `docs/` - Documentation including agent guide
- `tests/` - Test files
- `scripts/` - Utility scripts

## AI Agents Available
This project includes custom agents for {', '.join(tech_stack)} development:
- Project coordination and management
- Technology-specific implementation guidance
- Quality assurance and testing
- Deployment and infrastructure support

## Contributing
Follow the PRP system for all feature development.

## License
[Add license information]
"""
    
    with open(project_dir / "README.md", 'w') as f:
        f.write(readme_content)
    
    # Create .gitignore
    gitignore_content = """# Dependencies
node_modules/
venv/
__pycache__/

# Build outputs
dist/
build/
*.pyc

# Environment variables
.env
.env.local

# IDE files
.vscode/
.idea/

# OS files
.DS_Store
Thumbs.db

# Logs
*.log

# Temporary files
*.tmp
*.temp
"""
    
    with open(project_dir / ".gitignore", 'w') as f:
        f.write(gitignore_content)
    
    print("‚úÖ Created basic project structure")

# Main execution
if __name__ == "__main__":
    import sys
    
    project_description = " ".join(sys.argv[1:]) if len(sys.argv) > 1 else None
    create_new_project(project_description)
```

## Meta-Agent Integration Benefits

### Project-Specific Agent Creation
The enhanced new-project command leverages the meta-agent to create custom AI agents tailored to your specific project:

- **Technology Stack Analysis**: Automatically detects technology requirements from project description
- **Custom Agent Generation**: Creates specialized agents for your tech stack (React, Django, PostgreSQL, etc.)
- **Domain Expertise**: Each agent provides deep knowledge for their specific domain
- **Coordinated Workflows**: Agents work together for complex multi-technology tasks

### Generated Agents by Technology
- **Frontend (React/Vue/Angular)**: UI development, state management, performance optimization
- **Backend (Node.js/Django/Spring)**: API design, business logic, architecture patterns
- **Database (PostgreSQL/MySQL/MongoDB)**: Schema design, query optimization, migration management
- **ML/AI (Python)**: Model development, data processing, pipeline management
- **DevOps (Cloud/Docker)**: Deployment, infrastructure, CI/CD pipeline management
- **Testing**: Comprehensive testing strategies across all technology layers
- **Project Coordination**: Workflow management and task prioritization

### Agent-Enhanced Development Workflow
1. **Intelligent Project Setup**: Technology stack detection and appropriate agent creation
2. **Specialized Guidance**: Domain experts provide context-aware assistance  
3. **Cross-Technology Integration**: Agents coordinate on full-stack features
4. **Quality Assurance**: Built-in quality checks and best practices from each domain
5. **Scalable Architecture**: Agents guide decisions for long-term maintainability

## Notes
- This command is designed for starting completely new projects with AI agent support
- It creates a comprehensive project foundation with custom AI assistance
- Includes detailed templates for new project development with agent integration
- Sets up the PRP system enhanced with project-specific agents
- Uses meta-agent to generate tailored AI specialists for your technology stack
- Provides clear next steps for agent-assisted project development 